{-# LANGUAGE LambdaCase #-}

-- A Library for Parser Combinators
-- This is type: Parser s a, and a set of functions that can generate primitive parsers
-- And combine them to form more complex parsers. The main interface is via do-notation
-- do
--    a <- someParser
--    b <- anotherParser
--    someOperation a b
-- This interface allows you to construct parsers that accept the results of previous parsers
-- and use them in other operations, combining in a way that respects any errors generated by the parsers.
-- A simple example would be:
-- test :: Parser Char Int
-- test = do
--     exact '('
--     a <- exact '0' <|> test
--     exact ')'
--     return a
-- Which matches any valid number of nested brackets around a zero. (i.e 0, (0), ((0)), (((0))) etc.)
module AME.Parser.Combinators where

import Control.Monad
import Control.Applicative

-- The possible values that a parser could expect:
--  A specific value, the end of the file, any character, or some described group.
data Vals s = S s | EOF | ANY | Describe String
             deriving (Show, Eq)

-- All the errors that the parser could throw.
-- Expected a b: a was expected but b was observed
-- WrongVal s: s was observed but another value was expected.
-- UnknownError: something else.
-- UnderlyingError: an error in the lexer, not the parser.
data ParseError s = Expected (Vals s) (Vals s)
                  | WrongVal s
                  | UnknownError
                  | UnderlyingError (ParseError Char)
                  deriving (Show, Eq)
    
-- Parser s a: takes a list of s and produces a value of type a.
newtype Parser s a = Parser {
    -- Parse the given input list, returning either the remaining input and a result, or an error.
    parse :: [s] -> Either (ParseError s) ([s], a)
}

instance Functor (Parser s) where
    --Parse a value, and apply a given function to the result, if the parse was successful.
    fmap f p = Parser $ fmap (fmap f) .  parse p
            --                           parse the original
            --          if it is successful, apply f
            -- wrap it in a new parser

-- A superclass required by Haskell's typesystem to implement Monad.
instance Applicative (Parser s) where
    pure = return
    f <*> a = do
        f' <- f
        a' <- a
        return $ f' a'

-- The real powerhouse of parser combinators.
instance Monad (Parser s) where
    -- return :: a -> Parser s a
    -- Make a parser that returns a given value without consuming any input.
    return = Parser . (return .) . flip (,)
    --                             take the value and put it in a tuple
    --                             take the input and put it in the other slot
    --                Indicate the parser was successful
    --       Wrap it in a new parser
    -- (>>=) :: Parser s a -> (a -> Parser s b) -> Parser s b
    -- The most powerful operation available for parsers:
    -- a >>= f means, construct a parser which, given some input
    -- parses the input using parser a, then, if it is successful,
    -- takes the result and applies a function f, which generates another parser
    -- which is the used to parse the remaining input. This is powerful because it is
    -- the underlying mechanism for do-notation. E.g)
    -- do 
    --    a <- p
    --    f a
    -- is equivalent to p >>= \a -> f a. Haskell's compiler
    -- compiles do-notation by deconstructing into calls to this function.
    a >>= f = Parser $ \s -> case parse a s of
                Left err -> Left err
                Right (s', a') -> parse (f a') s'

instance Alternative (Parser s) where
    -- (<|>) :: Parser s a -> Parser s a -> Parser s a
    -- Try using parser a, if it fails, use parser b instead.
    -- Crucially, this bactracks - if a fails after partially parsing the input
    -- b is started from the start of the text, NOT where a left off, 
    -- unlike in some other parser combinator libraries such as Parsec.
    a <|> b = Parser $ \s -> case parse a s of
        Left err -> parse b s
        Right x -> Right x
    -- empty :: Parser s a
    -- A parser that always fails.
    empty = throw UnknownError

-- Construct a parser which always fails with the given error.
throw :: ParseError s -> Parser s a
throw = Parser . const . Left

-- Try using a parser. If it doesn't work,
-- give the error to the provided function, and use the parser
-- that it provides as output, instead.
catch :: Parser s a -> (ParseError s -> Parser s a) -> Parser s a
catch p f = Parser $ \s -> case parse p s of
            Left err -> parse (f err) s
            Right x -> Right x

-- A parser that consumes one character from the input stream and returns it.
eat :: Parser s s
eat = Parser $ \case
        [] -> Left $ Expected ANY EOF -- In the case of an end of file, report that we expected something.
        s:ss -> Right (ss, s)

-- A parser that expectes it to be the end of input.
done :: Parser s ()
done = Parser $ \case
        [] -> Right ([], ()) -- If the input is empty, good
        s:_ -> Left $ Expected EOF (S s) -- Otherwise we got too much

-- A parser that consumes one character and checks it matches the given predicate
-- If not, it fails.
match :: (s -> Bool) -> Parser s s
match f = do
    c <- eat
    if f c
        then return c
        else throw $ WrongVal c

-- A simple wrapper around match that matches exactly the input provided
exact :: Eq s => s -> Parser s ()
exact = void . match . (==)

-- This is useful because String ~ [Char] so in order to exactly
-- match a String, on a Parser Char (i.e the lexer) we must use this.
word :: Eq s => [s] -> Parser s ()
word = mapM_ exact

-- Take a parser, and if it fails with a WrongVal
-- (i.e it is a `match` parser that failed)
-- Then replace that with a provided, more descriptive
-- error message.
expecting :: Vals s -> Parser s a -> Parser s a
expecting v p = p `catch` \case
        WrongVal c -> throw $ Expected v (S c)
        err -> throw err

-- Try and parse something. If it fails, ignore it and return Nothing.
opt :: Parser s a -> Parser s (Maybe a)
opt p = (Just <$> p) `catch` const (return Nothing)

-- A convenience function for parsing lists of things seperated by another expression
-- i.e lists of numbers seperated by commas.
sepBy :: Parser s a -> Parser s b -> Parser s [a]
sepBy a b = do
    first <- a
    rest <- many $ b >> a
    return $ first : rest
